/*
 * Orkes Conductor API Server
 * Orkes Conductor API Server
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.orkes.conductor.client.http.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.orkes.conductor.client.http.model.TaskExecLog;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * TaskResult
 */


public class TaskResult {
  @SerializedName("callbackAfterSeconds")
  private Long callbackAfterSeconds = null;

  @SerializedName("externalOutputPayloadStoragePath")
  private String externalOutputPayloadStoragePath = null;

  @SerializedName("logs")
  private List<TaskExecLog> logs = null;

  @SerializedName("outputData")
  private Map<String, Object> outputData = null;

  @SerializedName("reasonForIncompletion")
  private String reasonForIncompletion = null;

  public TaskResult(Task task) {
    this.workflowInstanceId = task.getWorkflowInstanceId();
    this.taskId = task.getTaskId();
    this.reasonForIncompletion = task.getReasonForIncompletion();
    this.callbackAfterSeconds = task.getCallbackAfterSeconds();
    this.workerId = task.getWorkerId();
    this.outputData = task.getOutputData();
    this.externalOutputPayloadStoragePath = task.getExternalOutputPayloadStoragePath();
    this.subWorkflowId = task.getSubWorkflowId();
    switch (task.getStatus()) {
        case CANCELED:
        case COMPLETED_WITH_ERRORS:
        case TIMED_OUT:
        case SKIPPED:
            this.status = StatusEnum.FAILED;
            break;
        case SCHEDULED:
            this.status = StatusEnum.IN_PROGRESS;
            break;
        default:
            this.status = StatusEnum.valueOf(task.getStatus().name());
            break;
    }
}

  /**
   * Gets or Sets status
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    IN_PROGRESS("IN_PROGRESS"),
    FAILED("FAILED"),
    FAILED_WITH_TERMINAL_ERROR("FAILED_WITH_TERMINAL_ERROR"),
    COMPLETED("COMPLETED");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String input) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StatusEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("status")
  private StatusEnum status = null;

  @SerializedName("subWorkflowId")
  private String subWorkflowId = null;

  @SerializedName("taskId")
  private String taskId = null;

  @SerializedName("workerId")
  private String workerId = null;

  @SerializedName("workflowInstanceId")
  private String workflowInstanceId = null;

  public TaskResult callbackAfterSeconds(Long callbackAfterSeconds) {
    this.callbackAfterSeconds = callbackAfterSeconds;
    return this;
  }

   /**
   * Get callbackAfterSeconds
   * @return callbackAfterSeconds
  **/
  @Schema(description = "")
  public Long getCallbackAfterSeconds() {
    return callbackAfterSeconds;
  }

  public void setCallbackAfterSeconds(Long callbackAfterSeconds) {
    this.callbackAfterSeconds = callbackAfterSeconds;
  }

  public TaskResult externalOutputPayloadStoragePath(String externalOutputPayloadStoragePath) {
    this.externalOutputPayloadStoragePath = externalOutputPayloadStoragePath;
    return this;
  }

   /**
   * Get externalOutputPayloadStoragePath
   * @return externalOutputPayloadStoragePath
  **/
  @Schema(description = "")
  public String getExternalOutputPayloadStoragePath() {
    return externalOutputPayloadStoragePath;
  }

  public void setExternalOutputPayloadStoragePath(String externalOutputPayloadStoragePath) {
    this.externalOutputPayloadStoragePath = externalOutputPayloadStoragePath;
  }

  public TaskResult logs(List<TaskExecLog> logs) {
    this.logs = logs;
    return this;
  }

  public TaskResult addLogsItem(TaskExecLog logsItem) {
    if (this.logs == null) {
      this.logs = new ArrayList<TaskExecLog>();
    }
    this.logs.add(logsItem);
    return this;
  }

   /**
   * Get logs
   * @return logs
  **/
  @Schema(description = "")
  public List<TaskExecLog> getLogs() {
    return logs;
  }

  public void setLogs(List<TaskExecLog> logs) {
    this.logs = logs;
  }

  public TaskResult outputData(Map<String, Object> outputData) {
    this.outputData = outputData;
    return this;
  }

  public TaskResult putOutputDataItem(String key, Object outputDataItem) {
    if (this.outputData == null) {
      this.outputData = new HashMap<String, Object>();
    }
    this.outputData.put(key, outputDataItem);
    return this;
  }

   /**
   * Get outputData
   * @return outputData
  **/
  @Schema(description = "")
  public Map<String, Object> getOutputData() {
    return outputData;
  }

  public void setOutputData(Map<String, Object> outputData) {
    this.outputData = outputData;
  }

  public TaskResult reasonForIncompletion(String reasonForIncompletion) {
    this.reasonForIncompletion = reasonForIncompletion;
    return this;
  }

   /**
   * Get reasonForIncompletion
   * @return reasonForIncompletion
  **/
  @Schema(description = "")
  public String getReasonForIncompletion() {
    return reasonForIncompletion;
  }

  public void setReasonForIncompletion(String reasonForIncompletion) {
    this.reasonForIncompletion = reasonForIncompletion;
  }

  public TaskResult status(StatusEnum status) {
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @Schema(description = "")
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }

  public TaskResult subWorkflowId(String subWorkflowId) {
    this.subWorkflowId = subWorkflowId;
    return this;
  }

   /**
   * Get subWorkflowId
   * @return subWorkflowId
  **/
  @Schema(description = "")
  public String getSubWorkflowId() {
    return subWorkflowId;
  }

  public void setSubWorkflowId(String subWorkflowId) {
    this.subWorkflowId = subWorkflowId;
  }

  public TaskResult taskId(String taskId) {
    this.taskId = taskId;
    return this;
  }

   /**
   * Get taskId
   * @return taskId
  **/
  @Schema(required = true, description = "")
  public String getTaskId() {
    return taskId;
  }

  public void setTaskId(String taskId) {
    this.taskId = taskId;
  }

  public TaskResult workerId(String workerId) {
    this.workerId = workerId;
    return this;
  }

   /**
   * Get workerId
   * @return workerId
  **/
  @Schema(description = "")
  public String getWorkerId() {
    return workerId;
  }

  public void setWorkerId(String workerId) {
    this.workerId = workerId;
  }

  public TaskResult workflowInstanceId(String workflowInstanceId) {
    this.workflowInstanceId = workflowInstanceId;
    return this;
  }

   /**
   * Get workflowInstanceId
   * @return workflowInstanceId
  **/
  @Schema(required = true, description = "")
  public String getWorkflowInstanceId() {
    return workflowInstanceId;
  }

  public void setWorkflowInstanceId(String workflowInstanceId) {
    this.workflowInstanceId = workflowInstanceId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TaskResult taskResult = (TaskResult) o;
    return Objects.equals(this.callbackAfterSeconds, taskResult.callbackAfterSeconds) &&
        Objects.equals(this.externalOutputPayloadStoragePath, taskResult.externalOutputPayloadStoragePath) &&
        Objects.equals(this.logs, taskResult.logs) &&
        Objects.equals(this.outputData, taskResult.outputData) &&
        Objects.equals(this.reasonForIncompletion, taskResult.reasonForIncompletion) &&
        Objects.equals(this.status, taskResult.status) &&
        Objects.equals(this.subWorkflowId, taskResult.subWorkflowId) &&
        Objects.equals(this.taskId, taskResult.taskId) &&
        Objects.equals(this.workerId, taskResult.workerId) &&
        Objects.equals(this.workflowInstanceId, taskResult.workflowInstanceId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(callbackAfterSeconds, externalOutputPayloadStoragePath, logs, outputData, reasonForIncompletion, status, subWorkflowId, taskId, workerId, workflowInstanceId);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TaskResult {\n");
    
    sb.append("    callbackAfterSeconds: ").append(toIndentedString(callbackAfterSeconds)).append("\n");
    sb.append("    externalOutputPayloadStoragePath: ").append(toIndentedString(externalOutputPayloadStoragePath)).append("\n");
    sb.append("    logs: ").append(toIndentedString(logs)).append("\n");
    sb.append("    outputData: ").append(toIndentedString(outputData)).append("\n");
    sb.append("    reasonForIncompletion: ").append(toIndentedString(reasonForIncompletion)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subWorkflowId: ").append(toIndentedString(subWorkflowId)).append("\n");
    sb.append("    taskId: ").append(toIndentedString(taskId)).append("\n");
    sb.append("    workerId: ").append(toIndentedString(workerId)).append("\n");
    sb.append("    workflowInstanceId: ").append(toIndentedString(workflowInstanceId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
